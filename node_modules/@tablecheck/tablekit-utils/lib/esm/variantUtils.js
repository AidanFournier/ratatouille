function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

import deepmerge from 'deepmerge';
var isDev = process.env.NODE_ENV !== 'production';
/* istanbul ignore next */

var identity = function identity(x) {
  return x;
};

var is = function is(n) {
  return n !== undefined && n !== null;
};

var num = function num(n) {
  return typeof n === 'number' && !Number.isNaN(n);
};

var string = function string(n) {
  return typeof n === 'string' && n !== '';
};

var obj = function obj(n) {
  return _typeof(n) === 'object' && n !== null;
};

var func = function func(n) {
  return typeof n === 'function';
};

var negative = function negative(n) {
  return num(n) && n < 0;
};

var get = function get(from, path) {
  var paths = String(path).split('.');
  var pathsLength = paths.length;
  var result = from;

  for (var i = 0; i < pathsLength; i += 1) {
    if (result === undefined) return result;
    var pathKey = paths[i];
    result = is(result[pathKey]) ? result[pathKey] : undefined;
  }

  return result;
};

var merge = function merge(acc, item) {
  if (!is(item)) {
    return acc;
  } // No need to clone deep, it's way faster.


  return deepmerge(acc, item, {
    clone: false
  });
};

var warn = function warn(condition, message) {
  /* istanbul ignore next */
  if (isDev) {
    if (!condition && console.error) {
      console.error(message);
    }
  }
};

var cascade = function cascade(fn) {
  if (!func(fn)) return fn; // eslint-disable-next-line @typescript-eslint/ban-types

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var next = fn.apply(void 0, args);
  return cascade.apply(void 0, [next].concat(args));
};

var getValue = function getValue(props, // this is about the best we can do, sadly there is no good way of typing this
// https://github.com/microsoft/TypeScript/issues/12290
path) {
  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return cascade(get(initial, path.toString()), props);
};

var getThemeValue = function getThemeValue(props, // this is about the best we can do, sadly there is no good way of typing this
// https://github.com/microsoft/TypeScript/issues/12290
path) {
  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : props.theme;
  return cascade(get(initial, path.toString()), props);
};

export { cascade, func, get, getThemeValue, getValue, identity, is, merge, negative, num, obj, string, warn };
