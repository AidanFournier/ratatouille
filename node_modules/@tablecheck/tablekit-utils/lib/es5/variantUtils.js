"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warn = exports.string = exports.obj = exports.num = exports.negative = exports.merge = exports.is = exports.identity = exports.getValue = exports.getThemeValue = exports.get = exports.func = exports.cascade = void 0;

var _deepmerge = _interopRequireDefault(require("deepmerge"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var isDev = process.env.NODE_ENV !== 'production';
/* istanbul ignore next */

var identity = function identity(x) {
  return x;
};

exports.identity = identity;

var is = function is(n) {
  return n !== undefined && n !== null;
};

exports.is = is;

var num = function num(n) {
  return typeof n === 'number' && !Number.isNaN(n);
};

exports.num = num;

var string = function string(n) {
  return typeof n === 'string' && n !== '';
};

exports.string = string;

var obj = function obj(n) {
  return _typeof(n) === 'object' && n !== null;
};

exports.obj = obj;

var func = function func(n) {
  return typeof n === 'function';
};

exports.func = func;

var negative = function negative(n) {
  return num(n) && n < 0;
};

exports.negative = negative;

var get = function get(from, path) {
  var paths = String(path).split('.');
  var pathsLength = paths.length;
  var result = from;

  for (var i = 0; i < pathsLength; i += 1) {
    if (result === undefined) return result;
    var pathKey = paths[i];
    result = is(result[pathKey]) ? result[pathKey] : undefined;
  }

  return result;
};

exports.get = get;

var merge = function merge(acc, item) {
  if (!is(item)) {
    return acc;
  } // No need to clone deep, it's way faster.


  return (0, _deepmerge.default)(acc, item, {
    clone: false
  });
};

exports.merge = merge;

var warn = function warn(condition, message) {
  /* istanbul ignore next */
  if (isDev) {
    if (!condition && console.error) {
      console.error(message);
    }
  }
};

exports.warn = warn;

var cascade = function cascade(fn) {
  if (!func(fn)) return fn; // eslint-disable-next-line @typescript-eslint/ban-types

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var next = fn.apply(void 0, args);
  return cascade.apply(void 0, [next].concat(args));
};

exports.cascade = cascade;

var getValue = function getValue(props, // this is about the best we can do, sadly there is no good way of typing this
// https://github.com/microsoft/TypeScript/issues/12290
path) {
  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return cascade(get(initial, path.toString()), props);
};

exports.getValue = getValue;

var getThemeValue = function getThemeValue(props, // this is about the best we can do, sadly there is no good way of typing this
// https://github.com/microsoft/TypeScript/issues/12290
path) {
  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : props.theme;
  return cascade(get(initial, path.toString()), props);
};

exports.getThemeValue = getThemeValue;
