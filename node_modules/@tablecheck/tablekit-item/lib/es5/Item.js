"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Item = void 0;

var _tablekitTheme = require("@tablecheck/tablekit-theme");

var React = _interopRequireWildcard(require("react"));

var _Item = require("./styled/Item.js");

var _types = require("./types.js");

var _jsxRuntime = require("@emotion/react/jsx-runtime");

var _theme = require("./utils/theme.js");

var _excluded = ["component"],
    _excluded2 = ["children", "elemAfter", "elemBefore", "isDisabled", "isSelected", "isHidden", "href", "to", "borderPosition", "size", "role", "onClick", "onKeyDown", "shouldCenterAlignment", "onMouseDown", "useInteractionStateAsClass", "tabIndex"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var ItemContainer = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var component = _ref.component,
      otherProps = _objectWithoutProperties(_ref, _excluded);

  var ResolvedComponent = _Item.ItemBaseHtml;

  if (component) {
    ResolvedComponent = _Item.ItemBaseComponent.withComponent(component, process.env.NODE_ENV === "production" ? {
      target: "eezbx150"
    } : {
      target: "eezbx150",
      label: "ResolvedComponent"
    });
  } else if (otherProps.href) {
    ResolvedComponent = _Item.ItemBaseHtml.withComponent('a', process.env.NODE_ENV === "production" ? {
      target: "eezbx151"
    } : {
      target: "eezbx151",
      label: "ResolvedComponent"
    });
  }

  return (0, _jsxRuntime.jsx)(ResolvedComponent, _objectSpread({
    ref: ref
  }, otherProps));
});
var Item = /*#__PURE__*/React.forwardRef(function (_ref2, ref) {
  var children = _ref2.children,
      elemAfter = _ref2.elemAfter,
      elemBefore = _ref2.elemBefore,
      _ref2$isDisabled = _ref2.isDisabled,
      isDisabled = _ref2$isDisabled === void 0 ? false : _ref2$isDisabled,
      isSelected = _ref2.isSelected,
      _ref2$isHidden = _ref2.isHidden,
      isHidden = _ref2$isHidden === void 0 ? false : _ref2$isHidden,
      href = _ref2.href,
      to = _ref2.to,
      _ref2$borderPosition = _ref2.borderPosition,
      borderPosition = _ref2$borderPosition === void 0 ? _types.ItemBorderPosition.Left : _ref2$borderPosition,
      _ref2$size = _ref2.size,
      size = _ref2$size === void 0 ? _tablekitTheme.Size.Regular : _ref2$size,
      _ref2$role = _ref2.role,
      role = _ref2$role === void 0 ? 'button' : _ref2$role,
      _onClick = _ref2.onClick,
      _onKeyDown = _ref2.onKeyDown,
      _ref2$shouldCenterAli = _ref2.shouldCenterAlignment,
      shouldCenterAlignment = _ref2$shouldCenterAli === void 0 ? false : _ref2$shouldCenterAli,
      _onMouseDown = _ref2.onMouseDown,
      useInteractionStateAsClass = _ref2.useInteractionStateAsClass,
      _ref2$tabIndex = _ref2.tabIndex,
      tabIndex = _ref2$tabIndex === void 0 ? 0 : _ref2$tabIndex,
      rest = _objectWithoutProperties(_ref2, _excluded2);

  var interactionState = _types.ItemInteractionState.Default;

  if (isHidden) {
    interactionState = _types.ItemInteractionState.Hidden;
  } else if (isDisabled) {
    interactionState = _types.ItemInteractionState.Disabled;
  } else if (isSelected) {
    interactionState = _types.ItemInteractionState.Selected;
  }

  var interactionProps = {
    interactionState: interactionState,
    useVariantAsClass: useInteractionStateAsClass ? 'interactionState' : undefined
  };
  var patchedEventHandlers = {
    onClick: function onClick(event) {
      if (event.defaultPrevented) {
        return;
      }

      if (!isDisabled && _onClick) {
        _onClick(event);
      }
    },
    onMouseDown: function onMouseDown(event) {
      // We want to prevent the item from getting focus when clicked
      event.preventDefault(); // but we still need to blur other content

      var currentFocused = document.querySelector(':focus');

      if (currentFocused && currentFocused) {
        currentFocused.blur();
      }

      if (!isDisabled && _onMouseDown) {
        _onMouseDown(event);
      }
    },
    onKeyDown: function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }

      if (!isDisabled && _onKeyDown) {
        _onKeyDown(event);
      }
    }
  };
  var hasOnlyIcon = !children && (!!elemBefore && !elemAfter || !!elemAfter && !elemBefore);
  return (0, _jsxRuntime.jsxs)(ItemContainer, _objectSpread(_objectSpread(_objectSpread(_objectSpread({
    "aria-disabled": isDisabled,
    role: role,
    isSelected: isSelected,
    isHidden: isHidden,
    isDisabled: isDisabled,
    tabIndex: isDisabled || isHidden ? -1 : tabIndex,
    ref: ref,
    shouldCenterAlignment: shouldCenterAlignment,
    href: isDisabled ? undefined : href,
    to: isDisabled ? undefined : to,
    hasOnlyIcon: hasOnlyIcon,
    size: size,
    borderPosition: borderPosition
  }, rest), patchedEventHandlers), interactionProps), {}, {
    children: [!!elemBefore && (0, _jsxRuntime.jsx)(_theme.ElementBefore, {
      hasOnlyIcon: hasOnlyIcon,
      size: size,
      children: elemBefore
    }), !!children && (0, _jsxRuntime.jsx)(_Item.ItemContent, {
      shouldCenterAlignment: shouldCenterAlignment,
      children: children
    }), !!elemAfter && (0, _jsxRuntime.jsx)(_theme.ElementAfter, {
      hasOnlyIcon: hasOnlyIcon,
      size: size,
      children: elemAfter
    })]
  }));
});
exports.Item = Item;

Item.withComponent = function withComponent(newComponent) {
  // we have to disable typescript checking here or we risk JS Heap overflows on compliling
  // the function signature is correct so this should be fine as it's just a wrapper
  // eslint-disable-next-line @typescript-eslint/naming-convention
  var UntypedItem = Item;
  return /*#__PURE__*/React.forwardRef(function (props, ref) {
    return (0, _jsxRuntime.jsx)(UntypedItem, _objectSpread(_objectSpread({}, props), {}, {
      ref: ref,
      component: newComponent
    }));
  });
};
