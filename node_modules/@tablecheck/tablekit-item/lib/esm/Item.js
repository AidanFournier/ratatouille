var _excluded = ["component"],
    _excluded2 = ["children", "elemAfter", "elemBefore", "isDisabled", "isSelected", "isHidden", "href", "to", "borderPosition", "size", "role", "onClick", "onKeyDown", "shouldCenterAlignment", "onMouseDown", "useInteractionStateAsClass", "tabIndex"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { Size } from '@tablecheck/tablekit-theme';
import * as React from 'react';
import { ItemBaseHtml, ItemBaseComponent, ItemContent } from './styled/Item.js';
import { ItemBorderPosition, ItemInteractionState } from './types.js';
import { jsx, jsxs } from '@emotion/react/jsx-runtime';
import { ElementBefore, ElementAfter } from './utils/theme.js';
var ItemContainer = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var component = _ref.component,
      otherProps = _objectWithoutProperties(_ref, _excluded);

  var ResolvedComponent = ItemBaseHtml;

  if (component) {
    ResolvedComponent = ItemBaseComponent.withComponent(component, process.env.NODE_ENV === "production" ? {
      target: "eezbx150"
    } : {
      target: "eezbx150",
      label: "ResolvedComponent"
    });
  } else if (otherProps.href) {
    ResolvedComponent = ItemBaseHtml.withComponent('a', process.env.NODE_ENV === "production" ? {
      target: "eezbx151"
    } : {
      target: "eezbx151",
      label: "ResolvedComponent"
    });
  }

  return jsx(ResolvedComponent, _objectSpread({
    ref: ref
  }, otherProps));
});
var Item = /*#__PURE__*/React.forwardRef(function (_ref2, ref) {
  var children = _ref2.children,
      elemAfter = _ref2.elemAfter,
      elemBefore = _ref2.elemBefore,
      _ref2$isDisabled = _ref2.isDisabled,
      isDisabled = _ref2$isDisabled === void 0 ? false : _ref2$isDisabled,
      isSelected = _ref2.isSelected,
      _ref2$isHidden = _ref2.isHidden,
      isHidden = _ref2$isHidden === void 0 ? false : _ref2$isHidden,
      href = _ref2.href,
      to = _ref2.to,
      _ref2$borderPosition = _ref2.borderPosition,
      borderPosition = _ref2$borderPosition === void 0 ? ItemBorderPosition.Left : _ref2$borderPosition,
      _ref2$size = _ref2.size,
      size = _ref2$size === void 0 ? Size.Regular : _ref2$size,
      _ref2$role = _ref2.role,
      role = _ref2$role === void 0 ? 'button' : _ref2$role,
      _onClick = _ref2.onClick,
      _onKeyDown = _ref2.onKeyDown,
      _ref2$shouldCenterAli = _ref2.shouldCenterAlignment,
      shouldCenterAlignment = _ref2$shouldCenterAli === void 0 ? false : _ref2$shouldCenterAli,
      _onMouseDown = _ref2.onMouseDown,
      useInteractionStateAsClass = _ref2.useInteractionStateAsClass,
      _ref2$tabIndex = _ref2.tabIndex,
      tabIndex = _ref2$tabIndex === void 0 ? 0 : _ref2$tabIndex,
      rest = _objectWithoutProperties(_ref2, _excluded2);

  var interactionState = ItemInteractionState.Default;

  if (isHidden) {
    interactionState = ItemInteractionState.Hidden;
  } else if (isDisabled) {
    interactionState = ItemInteractionState.Disabled;
  } else if (isSelected) {
    interactionState = ItemInteractionState.Selected;
  }

  var interactionProps = {
    interactionState: interactionState,
    useVariantAsClass: useInteractionStateAsClass ? 'interactionState' : undefined
  };
  var patchedEventHandlers = {
    onClick: function onClick(event) {
      if (event.defaultPrevented) {
        return;
      }

      if (!isDisabled && _onClick) {
        _onClick(event);
      }
    },
    onMouseDown: function onMouseDown(event) {
      // We want to prevent the item from getting focus when clicked
      event.preventDefault(); // but we still need to blur other content

      var currentFocused = document.querySelector(':focus');

      if (currentFocused && currentFocused) {
        currentFocused.blur();
      }

      if (!isDisabled && _onMouseDown) {
        _onMouseDown(event);
      }
    },
    onKeyDown: function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }

      if (!isDisabled && _onKeyDown) {
        _onKeyDown(event);
      }
    }
  };
  var hasOnlyIcon = !children && (!!elemBefore && !elemAfter || !!elemAfter && !elemBefore);
  return jsxs(ItemContainer, _objectSpread(_objectSpread(_objectSpread(_objectSpread({
    "aria-disabled": isDisabled,
    role: role,
    isSelected: isSelected,
    isHidden: isHidden,
    isDisabled: isDisabled,
    tabIndex: isDisabled || isHidden ? -1 : tabIndex,
    ref: ref,
    shouldCenterAlignment: shouldCenterAlignment,
    href: isDisabled ? undefined : href,
    to: isDisabled ? undefined : to,
    hasOnlyIcon: hasOnlyIcon,
    size: size,
    borderPosition: borderPosition
  }, rest), patchedEventHandlers), interactionProps), {}, {
    children: [!!elemBefore && jsx(ElementBefore, {
      hasOnlyIcon: hasOnlyIcon,
      size: size,
      children: elemBefore
    }), !!children && jsx(ItemContent, {
      shouldCenterAlignment: shouldCenterAlignment,
      children: children
    }), !!elemAfter && jsx(ElementAfter, {
      hasOnlyIcon: hasOnlyIcon,
      size: size,
      children: elemAfter
    })]
  }));
});

Item.withComponent = function withComponent(newComponent) {
  // we have to disable typescript checking here or we risk JS Heap overflows on compliling
  // the function signature is correct so this should be fine as it's just a wrapper
  // eslint-disable-next-line @typescript-eslint/naming-convention
  var UntypedItem = Item;
  return /*#__PURE__*/React.forwardRef(function (props, ref) {
    return jsx(UntypedItem, _objectSpread(_objectSpread({}, props), {}, {
      ref: ref,
      component: newComponent
    }));
  });
};

export { Item };
